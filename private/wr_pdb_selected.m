function [message,PDBind,PDBind2] = wr_pdb_selected(fname,idCode,score,single_model)
% function [message,PDBind,PDBind2] = wr_pdb_selected(fname,idCode,score,single_model)
%
% Writes a PDB file in format V 3.20 of the currently selected objects,
% which may stem from different structures
% if the number of models is inconsistent, the models will be inconsistent
% in the output
% connection information is lost (sorry)
% only the 
%   header, (HEADER)
%   title, (TITLE)
%   remarks on format and the originating program (REMARK 4, REMARK 5)
%   sequence information, (SEQRES)
%   sequence modifications, (MODRES)
%   information on nonstandard residues without their names (HET)
%   secondary structure information, this comes from an original PDB
%   structure (if any) or from HELIX, SHEET, LOOP definitions within MMM,
%   sheets are stored only in single-strand format (no registration)
%   definitions within MMM take precedence (HELIX, SHEET)
%   atom coordinates, (ATOM, HETATM)
%   model numbers (MODEL, ENDMDL)
%   master record (MASTER)
% are written
%
% fname     file name for output, extension .pdb is appended, if no
%           extension is present
% idCode    four-letter PDB code or pseudo-PDB code
% score     optional score of the model, stored as a remark
% single_model  optional flag for combining chains with different model
%               indices
%
% message   message on success/error
% PDBind    atom index array [Nx6], MMM indices for the N lines in the PDB
%           file, needed for Tinker interfacing, these indices correspond 
%           to the original structure 
% PDBind2   atom index array [Nx6], MMM indices for the N lines in the PDB
%           file, needed for Tinker interfacing, these indices correspond 
%           to structure that is generated by reading the PDB file (it may
%           have different chain ordering)
%
% G. Jeschke, 2009-17

global model
global chemistry

maxatoms = 100000;
PDBind = zeros(maxatoms,6);
PDBind2 = zeros(maxatoms,6);
PDBpoi = 0;

if ~exist('single_model','var')
    single_model = false;
end


message.error=0;
message.text='';

indices = sorted_selection; % get hierarchically sorted indices of all 
                            % selected objects on atom location level 
[flocations,~] = size(indices);

% determine, how many chains are contained
chain_indices = zeros(100,2);
cpoi = 0;
mins = min(indices(:,1));
maxs = max(indices(:,1));
for ks = mins:maxs
    cind = indices(indices(:,1) == ks,2);
    minc = min(cind);
    maxc = max(cind);
    for kc = minc:maxc
        if min(abs(cind-kc)) == 0 % this chain index is indeed in the selection
            cpoi = cpoi + 1;
            chain_indices(cpoi,1) = ks;
            chain_indices(cpoi,2) = kc;
        end
    end    
end
chain_indices = chain_indices(1:cpoi,:);
cassign = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ ';
cassign = cassign(1:cpoi);

sortpoi = 1:cpoi;

% determine number of distinct models and their indices
models = zeros(1,500);
modind = indices(:,3);
models(1) = modind(1);
if ~single_model
    mpoi = 1;
    modind = modind(modind ~= models(mpoi));
    while ~isempty(modind)
        mpoi = mpoi + 1;
        models(mpoi) = modind(1);
        modind = modind(modind ~= models(mpoi));
    end
    models = models(1:mpoi);
else
    models = 1;
end;

% initialize checksum values

numRemark=0; % number of REMARK records
numHet=0; % number of HET records
numHelix=0; % number of HELIX records
numSheet=0; % number of SHEET records
numSite=0;
numXform=0;
numCoord=0;
numTer=0;
numConect=0;
numSeq=0;


% append proper extension, if extension is missing
if ~contains(fname,'.'), fname=strcat(fname,'.pdb'); end;

% generate header line
header=sprintf('HEADER    CHIMERA BY MMM SELECTION');
header=fillstr(header,50);
today=date;
today=[today(1:7) today(10:11)];
header=sprintf('%s%s   %s',header,today,idCode);
% state supported format and originating program
format=sprintf('REMARK   4 %s COMPLIES WITH FORMAT V. 3.20, 01-DEC-08',idCode);
numRemark=numRemark+1;
origin=sprintf('REMARK   5 WRITTEN BY MMM (MODIFIED STRUCTURE)');
numRemark=numRemark+1;
    

fid=fopen(fname,'wt');
if fid==-1,
    message.error=1;
    message.text='File could not be written';
    return;
end;

fprintf(fid,'%s\n',header);
for k=1:cpoi, % loop over all title lines
    cadr = mk_address(chain_indices(k,:));
    fprintf(fid,'TITLE     CHAIN %s IS %s\n',cassign(k),cadr);
end;
fprintf(fid,'REMARK   4\n%s\n',format);
fprintf(fid,'REMARK   5\n%s\n',origin);
if exist('score','var')
    fprintf(fid,'REMARK   6\nREMARK   6 SCORE OF THE MODEL %5.2f\n',score);
end;
% write SEQRES records
for k = sortpoi,
    seqline=0;
    snum = chain_indices(k,1);
    cnum = chain_indices(k,2);
    cid = cassign(k);
    restags=model.structures{snum}(cnum).restags;
    poi=0;
    residues=(length(restags)-1)/4;
    while poi<residues
        seqline=seqline+1;
        tline=sprintf('SEQRES %3i %s %4i ',seqline,cid,residues); % initialize SEQRES line
        field=0;
        while field<13
            poi=poi+1;
            field=field+1;
            tline=sprintf('%s%4s',tline,restags(4*poi-2:4*poi));
            if poi>=residues, break; end
        end
        if length(tline)<70, tline=fillstr(tline,70); end
        fprintf(fid,'%s\n',tline);
        numSeq=numSeq+1;
    end
end

% write MODRES records
for kc = sortpoi
    cid = cassign(kc);
    snum = chain_indices(kc,1);
    cnum = chain_indices(kc,2);
    if isfield(model.structures{snum}(cnum),'mutations')
        mutated=length(model.structures{snum}(cnum).mutations);
        for k=1:mutated,
            fprintf(fid,'MODRES %s %s ',idCode,model.structures{snum}(cnum).mutations(k).modified);
            fprintf(fid,'%s %4i  ',cid,model.structures{snum}(cnum).mutations(k).number);
            fprintf(fid,'%s  ',model.structures{snum}(cnum).mutations(k).original);
            if isfield(model.structures{snum}(cnum).mutations(k),'comment'),
                fprintf(fid,'%s',model.structures{snum}(cnum).mutations(k).comment);
            end;
            fprintf(fid,'\n');
        end;
    end;
end;

% write HET records
for kc = sortpoi,
    cid = cassign(kc);
    snum = chain_indices(kc,1);
    cnum = chain_indices(kc,2);
    if isfield(model.structures{snum}(cnum),'het'),
        hetrecs=length(model.structures{snum}(cnum).het);
        for k=1:hetrecs,
            fprintf(fid,'HET    %3s  %s',model.structures{snum}(cnum).het(k).id,cid);
            fprintf(fid,'%4i   ',model.structures{snum}(cnum).het(k).number);
            fprintf(fid,'%5i   ',model.structures{snum}(cnum).het(k).hetrecs);
            if isfield(model.structures{snum}(cnum).het(k),'descriptor'),
                fprintf(fid,'%s',model.structures{snum}(cnum).het(k).descriptor);
            end;
            fprintf(fid,'\n');
            numHet=numHet+1;
        end;
    end;
end;

% write helix records
helices=0;
for kc = sortpoi,
    cid = cassign(kc);
    snum = chain_indices(kc,1);
    cnum = chain_indices(kc,2);
    if isfield(model.structures{snum}(cnum),'helix_defs') % user-defined helix records
        hnum=length(model.structures{snum}(cnum).helix_defs);
        for k=1:hnum,
            helices=helices+1;
            if isfield(model.structures{snum}(cnum).helix_defs{k},'class') % user has defined helix class
                hclass=model.structures{snum}(cnum).helix_defs{k}.class;
            else
                hclass=1; % default alpha-helix
            end;
            htag=model.structures{snum}(cnum).helix_defs{k}.name;
            if length(htag)>3, htag=htag(1:3); end;
            fprintf(fid,'HELIX  %3i %3s ',helices,htag);
            numHelix=numHelix+1;
            start_res=model.structures{snum}(cnum).helix_defs{k}.range(1);
            cr_tag=sprintf('%i',start_res);
            start_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
            start_name=model.structures{snum}(cnum).residues{1}.info(start_id).name; 
            end_res=model.structures{snum}(cnum).helix_defs{k}.range(2);
            end_id=[];
            while isempty(end_id) && end_res>1,
                cr_tag=sprintf('%i',end_res);
                end_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
                if isempty(end_id), end_res=end_res-1; end;
            end;
            if ~isempty(end_id),
                end_name=model.structures{snum}(cnum).residues{1}.info(end_id).name; 
                fprintf(fid,'%3s %s %4i  %3s %s %4i ',start_name,cid,start_res,end_name,cid,end_res);
                comment=model.structures{snum}(cnum).helix_defs{k}.name;
                if length(comment)>29, 
                    comment=comment(1:29);
                else
                    comment=fillstr(comment,29);
                end;
                fprintf(fid,'%2i %s %5i\n',hclass,comment,end_res-start_res+1);
            end;
        end;
    elseif model.structures{snum}(cnum).helices>0 % input PDB defined helix records
        hnum=model.structures{snum}(cnum).helices;
        for k=1:hnum,
            helices=helices+1;
            hclass=model.structures{snum}(cnum).helix(k).class;
            htag=model.structures{snum}(cnum).helix(k).name;
            if length(htag)>3, htag=htag(1:3); end;
            fprintf(fid,'HELIX  %3i %3s ',helices,htag);
            numHelix=numHelix+1;
            start_res=model.structures{snum}(cnum).helix(k).start;
            cr_tag=sprintf('%i',start_res);
            start_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
            start_name=model.structures{snum}(cnum).residues{1}.info(start_id).name; 
            end_res=model.structures{snum}(cnum).helix(k).end;
            cr_tag=sprintf('%i',end_res);
            end_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
            end_name=model.structures{snum}(cnum).residues{1}.info(end_id).name; 
            fprintf(fid,'%3s %s %4i  %3s %s %4i ',start_name,cid,start_res,end_name,cid,end_res);
            comment=sprintf('DEFINITION BY PDB ID %s',model.info{snum}.idCode);
            if length(comment)>29, 
                comment=comment(1:29);
            else
                comment=fillstr(comment,29);
            end;
            fprintf(fid,'%2i %s %5i\n',hclass,comment,end_res-start_res+1);
        end;
    end;
end;

% write sheet (strand) records
strands=0;
for kc = sortpoi,
    cid = cassign(kc);
    snum = chain_indices(kc,1);
    cnum = chain_indices(kc,2);
    if isfield(model.structures{snum}(cnum),'sheet_defs') % user-defined helix records
        shnum=length(model.structures{snum}(cnum).sheet_defs);
        for k=1:shnum,
            strands=strands+1;
            stag=model.structures{snum}(cnum).sheet_defs{k}.name;
            if length(stag)>3, stag=stag(1:3); end;
            fprintf(fid,'SHEET  %3i %3s 1 ',strands,stag);
            numSheet=numSheet+1;
            start_res=model.structures{snum}(cnum).sheet_defs{k}.range(1);
            cr_tag=sprintf('%i',start_res);
            start_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
            start_name=model.structures{snum}(cnum).residues{1}.info(start_id).name; 
            end_res=model.structures{snum}(cnum).sheet_defs{k}.range(2);
            cr_tag=sprintf('%i',end_res);
            end_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
            end_name=model.structures{snum}(cnum).residues{1}.info(end_id).name; 
            fprintf(fid,'%3s %s%4i  %3s %s%4i  0\n',start_name,cid,start_res,end_name,cid,end_res);
        end;
    elseif model.structures{snum}(cnum).strands>0 % input PDB defined sheet records
        shnum=model.structures{snum}(cnum).strands;
        for k=1:shnum,
            strands=strands+1;
            stag=model.structures{snum}(cnum).strand(k).name;
            if length(stag)>3, stag=stag(1:3); end;
            fprintf(fid,'SHEET  %3i %3s 1 ',strands,stag);
            numSheet=numSheet+1;
            start_res=model.structures{snum}(cnum).strand(k).start;
            cid1=char(model.structures{snum}(cnum).strand(k).s_c);
            cr_tag=sprintf('%i',start_res);
            start_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
            start_name=model.structures{snum}(cnum).residues{1}.info(start_id).name; 
            end_res=model.structures{snum}(cnum).strand(k).end;
            cid2=char(model.structures{snum}(cnum).strand(k).e_c);
            cr_tag=sprintf('%i',end_res);
            end_id=tag2id(cr_tag,model.structures{snum}(cnum).residues{1}.residue_tags);
            end_name=model.structures{snum}(cnum).residues{1}.info(end_id).name; 
            fprintf(fid,'%3s %s%4i  %3s %s%4i  0\n',start_name,cid1,start_res,end_name,cid2,end_res);
        end;
    end;
end;

% write ATOM and HETATM records


for km = 1:length(models),
    atnum=0; % initialize atom serial number
    if length(models)>1,
        fprintf(fid,'MODEL     %4i\n',km);
    end;
    for kloc = 1:flocations
        if indices(kloc,3) == models(km) || single_model
            PDBpoi = PDBpoi + 1;
            PDBind(PDBpoi,:) = indices(kloc,1:6);
            PDBind2(PDBpoi,:) = indices(kloc,1:6);
            snum = indices(kloc,1);
            cnum = indices(kloc,2);
            mnum = indices(kloc,3);
            rnum = indices(kloc,4);
            anum = indices(kloc,5);
            lnum = indices(kloc,6);
            compc = repmat([snum cnum],cpoi,1);
            kc = find(sum(abs(compc - chain_indices),2)==0);
            cid = cassign(kc);
            PDBind2(PDBpoi,2) = kc;
            rtag=model.structures{snum}(cnum).residues{mnum}.info(rnum).name;
            rid=sprintf('%4i ',model.structures{snum}(cnum).residues{mnum}.info(rnum).number);
            rid0=id2tag(rnum,model.structures{snum}(cnum).residues{mnum}.residue_tags);
            if double(rid0(end))<double('0') || double(rid0(end))>double('9'),
                rid(end)=rid0(end);
            end;
            if model.structures{snum}(cnum).residues{mnum}.info(rnum).hetflag,
                tline='HETATM';
                hetflag=1;
            else
                tline='ATOM  ';
                hetflag=0;
            end;
            if isfield(model.structures{snum}(cnum).residues{mnum}.info(rnum),'location_tags')
                ltags=model.structures{snum}(cnum).residues{mnum}.info(rnum).location_tags;
            else
                ltags=': :';
            end;
            pointer=model.structures{snum}(cnum).residues{mnum}.info(rnum).atom_numbers{anum};
            atag=id2tag(anum,model.structures{snum}(cnum).residues{mnum}.info(rnum).atom_tags);
            elnum=model.structures{snum}(cnum).residues{mnum}.info(rnum).elements(anum);
            element=upper(id2tag(elnum,chemistry.element_tags));
            if length(element)<2 && length(atag)<4,
                atag=[' ' atag];
            end;
            if length(atag)<4,
                atag=fillstr(atag,4);
            end;
            [~,n]=size(pointer);
            poi=pointer(lnum,1); % actual coordinate set number
            ltag='';
            if n>1,
                occupancy=pointer(lnum,2);
                ltag=id2tag(pointer(lnum,3),ltags);
            else
                occupancy=1.00;
            end;
            if isempty(ltag), ltag=' '; end;
            xyz=model.structures{snum}(cnum).xyz{mnum}(poi,:);
            Bfactor=model.structures{snum}(cnum).Bfactor{mnum}(poi);
            atnum=atnum+1;
            fprintf(fid,'%s%5i %4s%s%s %s%4s   %8.3f%8.3f%8.3f',tline,atnum,atag,ltag,rtag,cid,rid,xyz);
            fprintf(fid,'%6.2f%6.2f          %2s\n',occupancy,Bfactor,element);
            numCoord=numCoord+1;
            if sum(model.structures{snum}(cnum).Btensor{mnum}(poi,:))>=1, % write ANISOU record
                Btensor=model.structures{snum}(cnum).Btensor{mnum}(poi,:);
                fprintf(fid,'ANISOU%5i %4s%s%3s %s%4s %7i%7i%7i%7i%7i%7i',atnum,atag,ltag,rtag,cid,rid,Btensor);
                fprintf(fid,'      %2s\n',element);
            end;
            mismatch = false;
            if kloc == flocations
                mismatch = true;
            elseif sum(abs(indices(kloc,1:3)-indices(kloc+1,1:3))) > 0
                mismatch = true;
            end;
            if mismatch
                atnum=atnum+1;
                fprintf(fid,'TER   %5i      %3s %s%4s\n',atnum,rtag,cid,rid);
                numTer=numTer+1;
            end;
        end;
    end;
    if length(models)>1,
        fprintf(fid,'ENDMDL\n');
    end;
end;


% write MASTER record
fprintf(fid,'MASTER    %5i%5i%5i%5i%5i%5i%5i%5i%5i%5i%5i%5i\n',numRemark,0,numHet,numHelix,numSheet,0,numSite,numXform,numCoord,numTer,numConect,numSeq);

% don't forget to close it politely
fprintf(fid,'END   \n');
fclose(fid);

PDBind = PDBind(1:PDBpoi,:);
PDBind2 = PDBind2(1:PDBpoi,:);

function newstring=fillstr(string,newlength)
% pads a string with spaces

format=sprintf('%%s%%%is',newlength-length(string));
newstring=sprintf(format,string,' ');
% newstring = char(padarray(uint8(string)', newlength-length(string), 32,'post')');


function doesit = contains(mystring,pattern)
% Matlab 2017 has this, but it is defined here for compatibility

poi = strfind(mystring,pattern);
doesit = ~isempty(poi);
